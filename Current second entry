//@version=5
strategy("Second Entry Strategy", overlay=true,  pyramiding=1, initial_capital=100, commission_value=0.05, default_qty_type=strategy.cash, default_qty_value=100, process_orders_on_close=false, calc_on_order_fills=false, calc_on_every_tick=true, use_bar_magnifier=true)

import mentalRock19315/Slope_TK/1 as TK

// Input Parameters
emaLength = input.int(21, "EMA Length")
pivotLegs = input.int(1, "Pivot Legs")
tpPercent = input.float(1.5, "Take Profit %")
slPercent = input.float(1.5, "Stop Loss %")

// Calculate EMA
ema = ta.ema(close, emaLength)
size = input.int(10, "Bars for Impulse slope")
maxSetupBars = input.int(25, "Maximum Bars for Setup", minval=1)
slope_value = input.int(20, "slope value")
ema_slope = TK.slope(ema, size)
ema_distance = math.abs((close - ema) / ema * 100)
ema_distance_thresh = input.float(0.5, "EMA distance Threshold %", minval=0, step = 0.1)

tolerance = input.float(0.5, "Price Tolerance %", minval=0.1, maxval=5, step=0.1)
maxPivots = input.int(20, "Max Pivots to Track", minval=5)
Pivot_thresh = input.int(7, "Max Pivots Threshold")
showLongs = input.bool(true, "Show Longs (Pivot Highs)")
showShorts = input.bool(true, "Show Shorts (Pivot Lows)")

// At the start of your script
[currLow, currHigh, prevLow] = request.security(syminfo.tickerid, timeframe.period, [low, high, low[1]], lookahead=barmerge.lookahead_off)

// Pivot High/Low Detection
leftBars = pivotLegs
rightBars = pivotLegs
ph = ta.pivothigh(high, leftBars, rightBars)
pl = ta.pivotlow(low, leftBars, rightBars)

// Pivot Storage Arrays
var float[] pivotHighPrices = array.new_float(0)
var int[] pivotHighBars = array.new_int(0)
var float[] pivotLowPrices = array.new_float(0)
var int[] pivotLowBars = array.new_int(0)

// State Variables {
var float pivotHigh = na
var float pivotLow = na
var int pivotHighBar = na
var int pivotLowBar = na
var float firstEntryHigh = na
var float firstEntryLow = na
var int firstEntryBarHigh = na
var int firstEntryBarLow = na
var float pullbackHigh = na
var float pullbackLow = na
var int pullbackBarLong = na
var int pullbackBarShort = na
var float secondEntryHigh = na
var float secondEntryLow = na
var bool inLongSetup = false
var bool inShortSetup = false
var bool waitingForPullback = false
var bool waitingForSecondEntryLong = false
var bool waitingForSecondEntryShort = false
var bool inTrade = false
var bool isFailedSetup = false
var bool pivotConfirmedHigh = false 
var bool pivotConfirmedLow = false 
//}


// Add global variables for stop loss and take profit
var float stopLoss = na
var float takeProfit = na
int secondEntryBar = na

lookback = 10
conditionMet = true

// ===============================================================================================================
// STEP 1: PIVOT DETECTION & CLASSIFICATION ==========================================================================={
// ===============================================================================================================

// Detect new pivot high/low and initiate setup only if we're not in an existing setup
for i = 0 to lookback - 1
    // Check if close price was NOT above the EMA for any of the bars
    if not (close[i] > ema[i])
        conditionMet := false
        break // Exit the loop as soon as one bar fails the condition

// ============================================================================
// PIVOT HIGH DETECTION AND CONFIRMATION
f_detectPivotHigh(float _ph, bool _inLongSetup, bool _inShortSetup, bool _waitingForPullback, 
                  bool _waitingForSecondEntry, float _pivotHigh, int _pivotHighBar,
                  array<float> _pivotHighPrices, array<int> _pivotHighBars, int _rightBars, int _maxPivots) =>
    
    newPivotHigh = _pivotHigh
    newPivotHighBar = _pivotHighBar
    newInLongSetup = _inLongSetup
    newPivotConfirmedHigh = false
    
    if _ph and not _inLongSetup and not _inShortSetup and not _waitingForPullback and not _waitingForSecondEntry and _ph > ema
        newPivotHigh := high[_rightBars]
        newPivotHighBar := bar_index[_rightBars]
        
        // Store in arrays
        array.unshift(_pivotHighPrices, newPivotHigh)
        array.unshift(_pivotHighBars, newPivotHighBar)
        
        // Keep only last maxPivots
        if array.size(_pivotHighPrices) > _maxPivots
            array.pop(_pivotHighPrices)
            array.pop(_pivotHighBars)
        
        newInLongSetup := true
        newPivotConfirmedHigh := false
    
    [newPivotHigh, newPivotHighBar, newInLongSetup, newPivotConfirmedHigh]

f_confirmPivotHigh(bool _inLongSetup, bool _pivotConfirmedHigh, bool _waitingForPullback, int _pivotHighBar) =>
    
    newPivotConfirmedHigh = _pivotConfirmedHigh
    
    int barsSincePivotHigh = bar_index - _pivotHighBar
    if _inLongSetup and not _pivotConfirmedHigh and not _waitingForPullback and not na(_pivotHighBar) and barsSincePivotHigh > 0
        if low[barsSincePivotHigh - 1] < low[barsSincePivotHigh]
            newPivotConfirmedHigh := true
    
    newPivotConfirmedHigh

// Usage for Pivot High Detection
[_tempPivotHigh, _tempPivotHighBar, _tempInLongSetup, _tempPivotConfHigh] = f_detectPivotHigh(ph, inLongSetup, inShortSetup, waitingForPullback, waitingForSecondEntryLong,
                      pivotHigh, pivotHighBar, pivotHighPrices, pivotHighBars, rightBars, maxPivots)

pivotHigh := _tempPivotHigh
pivotHighBar := _tempPivotHighBar
inLongSetup := _tempInLongSetup
pivotConfirmedHigh := _tempPivotConfHigh

// Usage for Pivot High Confirmation
pivotConfirmedHigh := f_confirmPivotHigh(inLongSetup, pivotConfirmedHigh, waitingForPullback, pivotHighBar)


// ============================================================================
// PIVOT LOW DETECTION AND CONFIRMATION
f_detectPivotLow(float _pl, bool _inLongSetup, bool _inShortSetup, bool _waitingForPullback, 
                 bool _waitingForSecondEntry, float _pivotLow, int _pivotLowBar,
                 array<float> _pivotLowPrices, array<int> _pivotLowBars, int _rightBars, int _maxPivots) =>
    
    newPivotLow = _pivotLow
    newPivotLowBar = _pivotLowBar
    newInShortSetup = _inShortSetup
    newPivotConfirmedLow = false
    
    if _pl and not _inLongSetup and not _inShortSetup and not _waitingForPullback and not _waitingForSecondEntry and _pl < ema
        newPivotLow := low[_rightBars]
        newPivotLowBar := bar_index[_rightBars]
        
        // Store in arrays
        array.unshift(_pivotLowPrices, newPivotLow)
        array.unshift(_pivotLowBars, newPivotLowBar)
        
        // Keep only last maxPivots
        if array.size(_pivotLowPrices) > _maxPivots
            array.pop(_pivotLowPrices)
            array.pop(_pivotLowBars)
        
        newInShortSetup := true
        newPivotConfirmedLow := false
    
    [newPivotLow, newPivotLowBar, newInShortSetup, newPivotConfirmedLow]

f_confirmPivotLow(bool _inShortSetup, bool _pivotConfirmedLow, bool _waitingForPullback, int _pivotLowBar) =>
    
    newPivotConfirmedLow = _pivotConfirmedLow
    
    int barsSincePivotLow = bar_index - _pivotLowBar
    if _inShortSetup and not _pivotConfirmedLow and not _waitingForPullback and not na(_pivotLowBar) and barsSincePivotLow > 0
        if high[barsSincePivotLow - 1] > high[barsSincePivotLow]
            newPivotConfirmedLow := true
    
    newPivotConfirmedLow

// Usage for Pivot Low Detection
[_tempPivotLow, _tempPivotLowBar, _tempInShortSetup, _tempPivotConfLow] = f_detectPivotLow(pl, inLongSetup, inShortSetup, waitingForPullback, waitingForSecondEntryShort,
                     pivotLow, pivotLowBar, pivotLowPrices, pivotLowBars, rightBars, maxPivots)

pivotLow := _tempPivotLow
pivotLowBar := _tempPivotLowBar
inShortSetup := _tempInShortSetup
pivotConfirmedLow := _tempPivotConfLow

// Usage for Pivot Low Confirmation
pivotConfirmedLow := f_confirmPivotLow(inShortSetup, pivotConfirmedLow, waitingForPullback, pivotLowBar)


// Function to count pivots near current price
f_countPivotHighsNearPrice(float currentPrice, float tolerancePct) =>
    int count = 0
    int arraySize = array.size(pivotHighPrices)
    
    // Only process if array has elements
    if arraySize > 0
        float toleranceRange = currentPrice * (tolerancePct / 100)
        
        for i = 0 to arraySize - 1
            float pivotPrice = array.get(pivotHighPrices, i)
            
            if math.abs(currentPrice - pivotPrice) <= toleranceRange
                count += 1
    
    count

f_countPivotLowsNearPrice(float currentPrice, float tolerancePct) =>
    int count = 0
    int arraySize = array.size(pivotLowPrices)
    
    // Only process if array has elements
    if arraySize > 0
        float toleranceRange = currentPrice * (tolerancePct / 100)
        
        for i = 0 to arraySize - 1
            float pivotPrice = array.get(pivotLowPrices, i)
            
            if math.abs(currentPrice - pivotPrice) <= toleranceRange
                count += 1
    
    count

// Calculate counts
pivotHighsNearby = showLongs ? f_countPivotHighsNearPrice(close, tolerance) : 0
pivotLowsNearby = showShorts ? f_countPivotLowsNearPrice(close, tolerance) : 0

//}

// ===============================================================================================================
// STEP 2: FE DETECTION ==============================================================================================={
// ===============================================================================================================
// First Entry Detection for Longs
f_handleLongSetupEntry(bool _inLongSetup, bool _waitingForPullback, bool _waitingForSecondEntry, 
                       float _pivotHigh, int _pivotHighBar, bool _pivotConfirmedHigh,
                       float _firstEntryHigh, float _firstEntryLow, int _firstEntryBarHigh) =>
    
    newFirstEntryHigh = _firstEntryHigh
    newFirstEntryLow = _firstEntryLow
    newFirstEntryBarHigh = _firstEntryBarHigh
    newWaitingForPullback = _waitingForPullback
    newInLongSetup = _inLongSetup
    newIsFailedSetup = false
    
    if _inLongSetup and not _waitingForPullback and not _waitingForSecondEntry and _pivotConfirmedHigh and strategy.position_size == 0
        
        if high > high[1] and high < _pivotHigh and bar_index > _pivotHighBar and close > ema and na(newFirstEntryBarHigh)
            newFirstEntryHigh := high
            newFirstEntryLow := low
            newFirstEntryBarHigh := bar_index
            newWaitingForPullback := true
        
        else if high > high[1] and high < _pivotHigh and bar_index > _pivotHighBar and close < ema and na(newFirstEntryBarHigh)
            newFirstEntryHigh := na
            newFirstEntryLow := na
            newFirstEntryBarHigh := na
            newWaitingForPullback := false
            newInLongSetup := false
            newIsFailedSetup := true
    
    [newFirstEntryHigh, newFirstEntryLow, newFirstEntryBarHigh, newWaitingForPullback, newInLongSetup, newIsFailedSetup]



// Use DIFFERENT variable names for the tuple assignment, then reassign
[_tempHigh, _tempLow, _tempBar, _tempPullback, _tempSetup, _tempFailed] = f_handleLongSetupEntry(inLongSetup, waitingForPullback, waitingForSecondEntryLong, 
                           pivotHigh, pivotHighBar, pivotConfirmedHigh, 
                           firstEntryHigh, firstEntryLow, firstEntryBarHigh)

// Now reassign to your actual variables
firstEntryHigh := _tempHigh
firstEntryLow := _tempLow
firstEntryBarHigh := _tempBar
waitingForPullback := _tempPullback
inLongSetup := _tempSetup
isFailedSetup := _tempFailed


// First Entry Detection for Shorts
f_handleShortSetupEntry(bool _inShortSetup, bool _waitingForPullback, bool _waitingForSecondEntry, 
                         float _pivotLow, int _pivotLowBar, bool _pivotConfirmedLow,
                         float _firstEntryHigh, float _firstEntryLow, int _firstEntryBarLow) =>
    
    newFirstEntryHigh = _firstEntryHigh
    newFirstEntryLow = _firstEntryLow
    newFirstEntryBarLow = _firstEntryBarLow
    newWaitingForPullback = _waitingForPullback
    newInShortSetup = _inShortSetup
    newIsFailedSetup = false
    
    if _inShortSetup and not _waitingForPullback and not _waitingForSecondEntry and _pivotConfirmedLow and strategy.position_size == 0
        
        // Valid entry below EMA
        if low < low[1] and low > _pivotLow and bar_index > _pivotLowBar and close < ema and na(newFirstEntryBarLow)
            newFirstEntryHigh := high
            newFirstEntryLow := low
            newFirstEntryBarLow := bar_index
            newWaitingForPullback := true
        
        // Failed setup - close above EMA
        else if low < low[1] and low > _pivotLow and bar_index > _pivotLowBar and close > ema and na(newFirstEntryBarLow)
            newFirstEntryHigh := na
            newFirstEntryLow := na
            newFirstEntryBarLow := na
            newWaitingForPullback := false
            newInShortSetup := false
            newIsFailedSetup := true
    
    [newFirstEntryHigh, newFirstEntryLow, newFirstEntryBarLow, newWaitingForPullback, newInShortSetup, newIsFailedSetup]

// Usage (assuming you already have these variables declared):
[_tempHighShort, _tempLowShort, _tempBarShort, _tempPullbackShort, _tempSetupShort, _tempFailedShort] = f_handleShortSetupEntry(inShortSetup, waitingForPullback, waitingForSecondEntryShort, 
                             pivotLow, pivotLowBar, pivotConfirmedLow, 
                             firstEntryHigh, firstEntryLow, firstEntryBarLow)

// Reassign to actual variables
firstEntryHigh := _tempHighShort
firstEntryLow := _tempLowShort
firstEntryBarLow := _tempBarShort
waitingForPullback := _tempPullbackShort
inShortSetup := _tempSetupShort
isFailedSetup := _tempFailedShort

// }

// ===============================================================================================================
// STEP 3: PULLBACK DETECTION ========================================================================================={
// ===============================================================================================================
// Pullback Detection for Longs 
f_detectLongPullback(bool _inLongSetup, bool _waitingForPullback, bool _waitingForSecondEntry,
                     int _firstEntryBarHigh, float _pullbackHigh, float _pullbackLow, int _pullbackBarLong) =>
    
    newPullbackHigh = _pullbackHigh
    newPullbackLow = _pullbackLow
    newPullbackBarLong = _pullbackBarLong
    newWaitingForPullback = _waitingForPullback
    newWaitingForSecondEntry = _waitingForSecondEntry
    
    if _inLongSetup and _waitingForPullback and not _waitingForSecondEntry and strategy.position_size == 0
        int barsSinceFE = bar_index - _firstEntryBarHigh
        if not na(_firstEntryBarHigh) and bar_index > _firstEntryBarHigh
            for i = 0 to barsSinceFE 
                if low[i] < low[i+1]
                    newPullbackHigh := high[i]
                    newPullbackLow := low[i]
                    newPullbackBarLong := bar_index[i]
                    newWaitingForPullback := false
                    newWaitingForSecondEntry := true
                    break
    
    [newPullbackHigh, newPullbackLow, newPullbackBarLong, newWaitingForPullback, newWaitingForSecondEntry]

// Usage for Long Pullback
[_tempPBHighLong, _tempPBLowLong, _tempPBBarLong, _tempWaitPBLong, _tempWaitSELong] = f_detectLongPullback(inLongSetup, waitingForPullback, waitingForSecondEntryLong,
                         firstEntryBarHigh, pullbackHigh, pullbackLow, pullbackBarLong)

pullbackHigh := _tempPBHighLong
pullbackLow := _tempPBLowLong
pullbackBarLong := _tempPBBarLong
waitingForPullback := _tempWaitPBLong
waitingForSecondEntryLong := _tempWaitSELong


// Pullback Detection for Shorts
f_detectShortPullback(bool _inShortSetup, bool _waitingForPullback, bool _waitingForSecondEntry,
                      int _firstEntryBarLow, float _pullbackHigh, float _pullbackLow, int _pullbackBarShort) =>
    
    newPullbackHigh = _pullbackHigh
    newPullbackLow = _pullbackLow
    newPullbackBarShort = _pullbackBarShort
    newWaitingForPullback = _waitingForPullback
    newWaitingForSecondEntry = _waitingForSecondEntry
    
    if _inShortSetup and _waitingForPullback and not _waitingForSecondEntry and strategy.position_size == 0
        int barsSinceFE = bar_index - _firstEntryBarLow
        if not na(_firstEntryBarLow) and bar_index > _firstEntryBarLow
            for i = 0 to barsSinceFE 
                if high[i] > high[i+1]
                    newPullbackHigh := high[i]
                    newPullbackLow := low[i]
                    newPullbackBarShort := bar_index[i]
                    newWaitingForPullback := false
                    newWaitingForSecondEntry := true
                    break
    
    [newPullbackHigh, newPullbackLow, newPullbackBarShort, newWaitingForPullback, newWaitingForSecondEntry]

// Usage for Short Pullback
[_tempPBHighShort, _tempPBLowShort, _tempPBBarShort, _tempWaitPBShort, _tempWaitSEShort] = f_detectShortPullback(inShortSetup, waitingForPullback, waitingForSecondEntryShort,
                          firstEntryBarLow, pullbackHigh, pullbackLow, pullbackBarShort)

pullbackHigh := _tempPBHighShort
pullbackLow := _tempPBLowShort
pullbackBarShort := _tempPBBarShort
waitingForPullback := _tempWaitPBShort
waitingForSecondEntryShort := _tempWaitSEShort

// }

// ===============================================================================================================
// STEP 4: SETUP FAILURE DETECTION ===================================================================================={
// ===============================================================================================================
// LONG SETUP INVALIDATION/RESET
f_checkLongSetupInvalidation(bool _inLongSetup, float _pivotHigh, int _pivotHighBar, int _maxSetupBars) =>
    
    shouldReset = false
    
    if _inLongSetup
        if high >= _pivotHigh or (_inLongSetup and (bar_index - _pivotHighBar) > _maxSetupBars)
            shouldReset := true
    
    shouldReset

// Usage for Long Setup Invalidation
if f_checkLongSetupInvalidation(inLongSetup, pivotHigh, pivotHighBar, maxSetupBars)
    pivotHigh := na
    pivotHighBar := na
    firstEntryHigh := na
    firstEntryBarHigh := na
    pullbackHigh := na
    pullbackBarLong := na
    secondEntryHigh := na
    inLongSetup := false
    waitingForPullback := false
    waitingForSecondEntryLong := false
    isFailedSetup := false
    pivotConfirmedHigh := false


// SHORT SETUP INVALIDATION/RESET
f_checkShortSetupInvalidation(bool _inShortSetup, float _pivotLow, int _pivotLowBar, int _maxSetupBars) =>
    
    shouldReset = false
    
    if _inShortSetup
        if low <= _pivotLow or (_inShortSetup and (bar_index - _pivotLowBar) > _maxSetupBars)
            shouldReset := true
    
    shouldReset

// Usage for Short Setup Invalidation
if f_checkShortSetupInvalidation(inShortSetup, pivotLow, pivotLowBar, maxSetupBars)
    pivotLow := na
    pivotLowBar := na
    firstEntryLow := na
    firstEntryBarLow := na
    pullbackLow := na
    pullbackBarShort := na
    secondEntryLow := na
    inShortSetup := false
    waitingForPullback := false
    waitingForSecondEntryShort := false
    isFailedSetup := false
    pivotConfirmedLow := false


// }

// ===============================================================================================================
// STEP 5: SECOND ENTRY DETECTION & EXECUTION ========================================================================={
// ===============================================================================================================
float second_entry_long_loc = 0
float second_entry_short_loc = 0
bool higherHighFound = false
bool LowerLowFound = false


// Second Entry Detection for Longs
if inLongSetup and waitingForSecondEntryLong and not inTrade
    ema_distance := math.abs((close - ema) / ema * 100)
    // Check if current bar has higher high than previous
    if high > high[1]
        second_entry_long_loc := high
        // If second entry forms below EMA, cancel setup

        // Only enter if we're above EMA
        int barsSincePullback = bar_index - pullbackBarLong
        if not na(pullbackBarLong) and bar_index > pullbackBarLong
            for i = 2 to barsSincePullback 
                if high[i] > high[i+1]
                    higherHighFound := true
                    break // Exit the loop immediately once a higher high is found

        if not higherHighFound and ema_slope > slope_value and ema_distance < ema_distance_thresh and pivotHighsNearby < Pivot_thresh
            strategy.close('Short', "early short exit")
            // Calculate bar distances
            var string entryComment = ""
            entryComment := "Second Entry Long | " + "Pivot: " + str.tostring(bar_index - pivotHighBar) + " | " + "First: " + str.tostring(bar_index - firstEntryBarHigh) + " | " + "PB: " + str.tostring(bar_index - pullbackBarLong)

            secondEntryHigh := high
            secondEntryLow := low
            secondEntryBar := bar_index
            strategy.entry("Long", strategy.long, comment=entryComment)
            inTrade := true
            pivotHigh := na
            pivotHighBar := na
            firstEntryHigh := na
            firstEntryBarHigh := na
            pullbackHigh := na
            pullbackBarLong := na
            secondEntryHigh := na
            inLongSetup := false
            waitingForPullback := false
            waitingForSecondEntryLong := false
            isFailedSetup := false
            pivotConfirmedHigh := false
            
            // Calculate stop loss and take profit levels
            stopLoss := close * (1 - slPercent/100)
            takeProfit := close * (1 + tpPercent/100)
            
            strategy.exit("Long Exit", "Long", stop=stopLoss, limit=takeProfit)



// Second Entry Detection for Shorts
if inShortSetup and waitingForSecondEntryShort and not inTrade
    ema_distance := math.abs((close - ema) / ema * 100)
    // Check if current bar has lower low than previous
    if low < low[1]
        second_entry_short_loc := low
        // Only enter if we're above EMA
        int barsSincePullback = bar_index - pullbackBarShort
        if not na(pullbackBarShort) and bar_index > pullbackBarShort
            for i = 2 to barsSincePullback 
                if low[i] < low[i+1]
                    higherHighFound := true
                    break // Exit the loop immediately once a higher high is found
        // Only enter if we're below EMA
        if not LowerLowFound and ema_slope < -slope_value and ema_distance < ema_distance_thresh and pivotLowsNearby < Pivot_thresh
            strategy.close('Long', "early long exit")
            // Calculate bar distances
            var string entryComment = ""
            entryComment := "Second Entry Short | " +  "Pivot: " + str.tostring(bar_index - pivotLowBar) + " | " + "First: " + str.tostring(bar_index - firstEntryBarLow) + " | " + "PB: " + str.tostring(bar_index - pullbackBarShort)
            secondEntryHigh := high
            secondEntryLow := low
            secondEntryBar := bar_index
            strategy.entry("Short", strategy.short, stop = prevLow, comment=entryComment)
            inTrade := true
            pivotLow := na
            pivotLowBar := na
            firstEntryLow := na
            firstEntryBarLow := na
            pullbackLow := na
            pullbackBarShort := na
            secondEntryLow := na
            inShortSetup := false
            waitingForPullback := false
            waitingForSecondEntryShort := false
            isFailedSetup := false
            pivotConfirmedLow := false
            
            // Calculate stop loss and take profit levels
            stopLoss := close * (1 + slPercent/100)
            takeProfit := close * (1 - tpPercent/100)
            
            strategy.exit("Short Exit", "Short", stop=stopLoss, limit=takeProfit)

plotarrow(second_entry_long_loc, colordown = color.rgb(255, 82, 82, 57), maxheight = 10)
plotarrow(-second_entry_short_loc, colorup = color.rgb(76, 175, 79, 54), maxheight = 10)

// }

// FAILED ENTRIES =======================================================================================================================
// Separate check for failed second entry long
if inTrade and strategy.position_size > 0 and not isFailedSetup and bar_index <= secondEntryBar + 1
    if low < low[1]
        strategy.close("SE Long", comment="Failed Second Entry Long")
        strategy.entry("Failed Long Short", strategy.short, comment="Failed Second Entry Short")
        isFailedSetup := true
        
        // Set SL/TP for the reversed position
        stopLoss := close * (1 + slPercent/100)
        takeProfit := close * (1 - tpPercent/100)
            

// Add these exit conditions for both initial and reversed positions
if strategy.position_size > 0
    strategy.exit("SE Long Exit", "SE Long", stop=stopLoss, limit=takeProfit)
    strategy.exit("FSE Long Exit", "Failed Short Long", stop=stopLoss, limit=takeProfit)
 
        
    
// Reset variables after trade completion or failure
if inTrade and strategy.position_size == 0
    pivotHigh := na
    pivotLow := na
    pivotHighBar := na
    pivotLowBar := na
    firstEntryHigh := na
    firstEntryLow := na
    firstEntryBarHigh := na
    firstEntryBarLow := na
    pullbackHigh := na
    pullbackLow := na
    pullbackBarLong := na
    pullbackBarShort := na
    secondEntryHigh := na
    secondEntryLow := na
    inLongSetup := false
    inShortSetup := false
    waitingForPullback := false
    waitingForSecondEntryLong := false
    waitingForSecondEntryShort := false
    inTrade := false
    isFailedSetup := false
    pivotConfirmedHigh := false 
    pivotConfirmedLow := false 



// Plot EMA
plot(ema, color=color.blue, title="21 EMA")

// Plot Pivot Points (Step 1)
plotshape(ph and not waitingForPullback and not waitingForSecondEntryLong and strategy.position_size <= 0 ? high[rightBars] : na, 
          title="Pivot High", location=location.absolute, 
          color=color.rgb(76, 175, 79, 54), style=shape.triangledown, size=size.tiny, offset=-rightBars)

plotshape(pl and not waitingForPullback and not waitingForSecondEntryShort and strategy.position_size >= 0 ? low[rightBars] : na, 
          title="Pivot Low", location=location.absolute, 
          color=color.rgb(255, 82, 82, 57), style=shape.triangleup, size=size.tiny, offset=-rightBars)

// Plot First Entry Points (Step 2)
plotshape(waitingForPullback and not waitingForSecondEntryLong and inLongSetup and high > high[1] and high < pivotHigh and bar_index == firstEntryBarHigh, title="First Entry Long", location=location.abovebar, color=color.green, style=shape.square, size=size.tiny)

plotshape(waitingForPullback and not waitingForSecondEntryShort and inShortSetup and low < low[1] and low > pivotLow and bar_index == firstEntryBarLow, title="First Entry Short", location=location.belowbar, color=color.red, style=shape.square, size=size.tiny)

// Plot Pullback Points (Step 3)
plotshape(waitingForSecondEntryLong and inLongSetup and bar_index == pullbackBarLong, 
          title="Pullback Long", location=location.belowbar, 
          color=color.green, style=shape.circle, size=size.tiny)

plotshape(waitingForSecondEntryShort and inShortSetup and bar_index == pullbackBarShort, 
          title="Pullback Short", location=location.abovebar, 
          color=color.red, style=shape.circle, size=size.tiny)

// Plot Second Entry Points (Step 4)
plotshape(inTrade and not isFailedSetup and strategy.position_size > 0, 
          title="Second Entry Long", location=location.belowbar, 
          color=color.green, style=shape.triangleup, size=size.normal)

plotshape(inTrade and not isFailedSetup and strategy.position_size < 0, 
          title="Second Entry Short", location=location.abovebar, 
          color=color.red, style=shape.triangledown, size=size.normal)

// Plot Failed Second Entries
plotshape(isFailedSetup and strategy.position_size > 0, 
          title="Failed Second Entry Short to Long", location=location.belowbar, 
          color=color.yellow, style=shape.triangleup, size=size.normal)

plotshape(isFailedSetup and strategy.position_size < 0, 
          title="Failed Second Entry Long to Short", location=location.abovebar, 
          color=color.yellow, style=shape.triangledown, size=size.normal)


// Add trend state label at the start of the script with other variables
var label trendLabel = label.new(x=bar_index, y=low,text="",color=color.gray,textcolor=color.white,style=label.style_label_up,size=size.normal,xloc=xloc.bar_index)



// Add labels for active setup state
var label setupLabel = na
label.delete(setupLabel[1])
if inLongSetup
    setupText = waitingForPullback ? "Waiting for Long Pullback" : waitingForSecondEntryLong ? "Waiting for Second Entry Long" : "Looking for First Entry Long"
    setupLabel := label.new(bar_index, high, setupText, color=color.green, textcolor=color.white)
else if inShortSetup
    setupText = waitingForPullback ? "Waiting for Short Pullback" : waitingForSecondEntryShort ? "Waiting for Second Entry Short" : "Looking for First Entry Short"
    setupLabel := label.new(bar_index, low, setupText, color=color.red, textcolor=color.white)

///
///
